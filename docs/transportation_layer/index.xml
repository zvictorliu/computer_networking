<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>第五章 传输层 on Computer Networking</title>
    <link>https://zvictorliu.github.io/computer_networking/transportation_layer/</link>
    <description>Recent content in 第五章 传输层 on Computer Networking</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://zvictorliu.github.io/computer_networking/transportation_layer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UDP协议</title>
      <link>https://zvictorliu.github.io/computer_networking/transportation_layer/udp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_networking/transportation_layer/udp/</guid>
      <description>UDP协议#适合一次性传输较少数据，虽然通信不可靠但是应用层还是有可靠性机制的
面向报文：不对传下来的应用层报文处理（而TCP会拆分），保留边界
应用层报文不可分割，是UDP数据报处理的最小单位
UDP适合一次性传输少量数据、对可靠性要求不高的场景
报文格式#首部+数据：
其中校验和可选，不用时全为0，用来检查是否出错
根据目的端口号找应用进程，找不到就丢弃，由ICMP发送不可达报文给发送端
校验#虽说可靠性机制在应用层，但校验还是UDP协议要做的，即宁差勿错
计算方法有点复杂。。。</description>
    </item>
    
    <item>
      <title>TCP协议</title>
      <link>https://zvictorliu.github.io/computer_networking/transportation_layer/tcp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zvictorliu.github.io/computer_networking/transportation_layer/tcp/</guid>
      <description>TCP协议#报文格式#各个字段的含义：
序号 TCP传输的每个字节都按顺序编号，序号字段存入本报文段数据的第一个自己序号 连接管理#建立#三个要求：
每一方都要知道对方的存在 双方需要协商某些参数 对运输实体资源分配 每条连接以两端的套接字确定，需要三次握手：
客户机向服务器发送请求报文段
这个报文段比较特殊，发出去后进入 SYN-SENT状态 服务器收到，同意，发回确认
进入SYN-RCVD状态 客户机收到后，再向服务器发出确认
进入ESTABLISHED状态 释放#四次握手
可靠传输实现#首部的确认号是期望对方收到的下一个报文段的序号，检查这个
累积确认方式，并不是按顺序的
超时和冗余ACK时会进行重传
收到比期望的序号大的，发送一个冗余ACK指明，当发送方收到3个冗余ACK后就会重传 流量控制#基于滑动窗口
拥塞控制#</description>
    </item>
    
  </channel>
</rss>
