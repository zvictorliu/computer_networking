---
title: 5.3 TCP流量、差错和可靠控制
type: docs
weight: 3
---

# TCP流量、差错和可靠

## 可靠传输

发送方将缓冲区内发送窗口中的数据发送出去，得到确认的数据进行删除，在还没有得到确认的情况下，发送方可将窗口内的全部数据都依次发送出去，收到确认后，窗口后沿向前移动（而前沿取决于拥塞窗口和接收窗口的大小）

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230628144914817.png" alt="image-20230628144914817" style="zoom:67%;" />

重传：发送了一个报文后就有一个超时重传计时器，当发送窗口内都已发送后不能再发送，等待确认或者超时；而为了快速重传则是冗余ACK机制

接收方收到的数据存入缓存区的接收窗口，只对按序接收的最高序号进行确认（累积确认，不是一个个确认），如果有不按序要等缺少的收到后再交给上层

*注意接收的TCP数据报往往不可能是只有一个字节数据，只是书上方便演示而已，所以实际是成段接收成段丢失，确认是每收到一段后发送的*

对于同时双向发送数据时，ACK是可以捎带在数据里的

## 流量控制

基于滑动窗口机制，接收方控制发送方的速率

一般是，接收方的确认信息中告知接收窗口的大小，发送方收到后移动窗口并调整大小（一般不建议让窗口缩小到把已经发送的也排除在外了，此外发送窗口是取接收窗口和拥塞窗口的最小值）

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230628152353817.png" alt="image-20230628152353817" style="zoom:67%;" />

此时发送方一方面滑动窗口另一方面窗口大小也要变化

补充：有可能窗口为0后，再修改窗口时的报文丢失，造成死锁，于是有一个持续计时器，进行0窗口探测

## 拥塞控制

拥塞： 对资源的需求超过了能提供的可用部分，是一个全局的状况

拥塞窗口由发送方动态维护

讨论时一般以最大报文段`MSS`为单位

### 慢开始算法

{{< columns >}}

传输轮次：完成一次窗口传输并得到确认

在未达到慢开始门限值`ssthresh`之前，发送窗口值`swnd`和拥塞窗口`cwnd`值取一样，每收到一个报文段确认就把拥塞窗口值+1，所以刚开始是指数增长

达到`ssthresh`之后，改用拥塞避免算法

<--->



<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230628155136621.png" alt="image-20230628155136621" style="zoom:80%;" />

{{< /columns >}}

### 拥塞避免算法

每个传输轮次后加一，此时是线性增长

当发生丢失时造成超时重传后，网络可能发送拥塞，于是此时应减小窗口：

- 将`ssthresh`更新为发生拥塞时的`cwnd`的一半
- 将`cwnd`取为1，再次执行慢开始算法，重头再来

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230628155849785.png" alt="image-20230628155849785" style="zoom:80%;" />

但是此时并不一定发生拥塞，发生了误解，所以有改进的快重传和快恢复

### 快重传

冗余ACK，当发送方收到3个连续的重复确认就重传，不等超时重传计时器

<img src="https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230628160350047.png" alt="image-20230628160350047" style="zoom:80%;" />

### 快恢复

收到3个重复确认即知道只是丢失个别，不启动慢开始算法，而执行快恢复算法：`ssthresh`还是取一半，`cwnd`取为`ssthresh`而不是从1开始（也可以适当扩大），然后执行拥塞避免算法

![image-20230628160800437](https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230628160800437.png)

