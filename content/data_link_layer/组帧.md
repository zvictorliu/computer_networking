---
title: 3.1 帧的封装
type: docs
weight: 1
---

# 组帧

将数据封装成帧的意义在于，如果出错不必完全重新传所有数据

组帧就是帧的封装，对上层传下来的信息进行封装，添加包含控制信息的帧头和帧尾

传给物理层将帧转成比特流发送出去，而作为接收方要从比特流中提取出一个个帧，就需要帧头帧尾的控制信息，知道什么时候开始什么时候结束，这就是`帧定界`

透明传输：数据链路层对上层传下来的数据没有任何限制，对于上层来说数据链路层是透明的; *如果数据中有部分和帧定界符意义，就会出现匹配错误，这样就叫对上层有限制了（不能包含和定界符相同的字段）* 

为实现透明传输的方法：

- 面向字节的物理链路：字符填充
- 面向比特的物理链路：比特填充

~~啥叫面向字节、面向比特？~~

## 1 字符计数法

在帧的头部使用一个计数字段，表面帧内的字符数，从而确定帧的结束

![image-20230618134011851](https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230618134011851.png)

但是这样风险比较大，一个有错后面都错了

## 2 字符填充法

 在首尾添加特定的字符

同时如果数据中有同样的字符，为了不误判，需要扫描一遍发现有同样特殊字符后就在其前面添加转义字符

接收时扫到转义字符就知道这个不是数据并且后面也不是特殊字符

![image-20230618134435813](https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230618134435813.png)

如果有和转义字符一样的，也可以通过首次出现来辨别

## 3 零比特填充

 面向比特的协议中使用

采用比特组合`01111110`来定界，对于数据中同样的部分：扫描，每出现5个连续的1就添加0

接收方扫描，每出现5个连续的1就删除后面的0

![image-20230618134923711](https://cdn.jsdelivr.net/gh/zvictorliu/typoraPics@main/img/image-20230618134923711.png)

## 4 违规编码

在物理层编码时采用的不同于用作区分01的其它编码方式

比如在曼彻斯特编码中：高to低表示1，低to高表示0，那么就可以用高to高表示开始，低to低表示结束

这样就不需要填充了

前提是编码方式有冗余
